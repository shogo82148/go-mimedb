package main

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"go/format"
	"io"
	"log"
	"net/http"
	"os"
	"slices"
	"strings"
)

const releaseURL = "https://github.com/jshttp/mime-db/releases/latest"
const databaseURL = "https://raw.githubusercontent.com/jshttp/mime-db/%s/db.json"

func main() {
	// get the latest release
	ctx := context.Background()
	latest, err := getLatestRelease(ctx)
	if err != nil {
		log.Fatal(err)
	}
	log.Println("latest release:", latest)

	// get the database
	db, err := getDatabase(ctx, latest)
	if err != nil {
		log.Fatal(err)
	}
	log.Println("database size:", len(db))

	// format extensions
	buf := new(bytes.Buffer)
	fmt.Fprintln(buf, "// Code generated by internal/cmd/update/main.go; DO NOT EDIT.")
	fmt.Fprintln(buf, "")
	fmt.Fprintln(buf, "package mimedb")
	fmt.Fprintln(buf, "")
	fmt.Fprintf(buf, "// The data is generated from [mime-db] version %s\n", latest)
	fmt.Fprintf(buf, "// [mime-db]: https://github.com/jshttp/mime-db\n")
	fmt.Fprintln(buf, "var extensions = map[string][]string{")
	types := make([]string, 0, len(db))
	for k := range db {
		types = append(types, k)
	}
	slices.Sort(types)

	for _, k := range types {
		v := db[k]
		if len(v.Extensions) == 0 {
			continue
		} else {
			fmt.Fprintf(buf, "\t%q: {", k)
			slices.Sort(v.Extensions)
			for i, ext := range v.Extensions {
				if i > 0 {
					fmt.Fprint(buf, ", ")
				}
				fmt.Fprintf(buf, "%q", "."+ext)
			}
			fmt.Fprintln(buf, "},")
		}
	}
	fmt.Fprintln(buf, "}")
	fmt.Fprintln(buf, "")

	// format mimeTypes and mimeTypesLower
	mimeTypes := make(map[string]string, len(db))
	mimeTypesLower := make(map[string]string, len(db))
	for _, k := range types {
		v := db[k]
		typ := k
		if v.Charset != "" {
			typ += "; charset=" + v.Charset
		}
		for _, ext := range v.Extensions {
			mimeTypes[ext] = typ
			mimeTypesLower[strings.ToLower(ext)] = typ
		}
	}

	exts := make([]string, 0, len(mimeTypes))
	for k := range mimeTypes {
		exts = append(exts, k)
	}
	slices.Sort(exts)

	fmt.Fprintln(buf, "var mimeTypes = map[string]string{")
	for _, ext := range exts {
		fmt.Fprintf(buf, "\t%q: %q,\n", "."+ext, mimeTypes[ext])
	}
	fmt.Fprintln(buf, "}")
	fmt.Fprintln(buf, "")

	fmt.Fprintln(buf, "var mimeTypesLower = map[string]string{")
	for _, ext := range exts {
		fmt.Fprintf(buf, "\t%q: %q,\n", "."+strings.ToLower(ext), mimeTypesLower[strings.ToLower(ext)])
	}
	fmt.Fprintln(buf, "}")

	source, err := format.Source(buf.Bytes())
	if err != nil {
		log.Fatal(err)
	}

	if err := os.WriteFile("mimedb_generated.go", source, 0644); err != nil {
		log.Fatal(err)
	}
}

type release struct {
	TagName string `json:"tag_name"`
}

func getLatestRelease(ctx context.Context) (string, error) {
	req, err := http.NewRequestWithContext(ctx, http.MethodGet, releaseURL, nil)
	if err != nil {
		return "", err
	}
	req.Header.Set("Accept", "application/json")
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	data, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	var r release
	if err := json.Unmarshal(data, &r); err != nil {
		return "", err
	}

	return r.TagName, nil
}

type entry struct {
	Source       string   `json:"source"`
	Extensions   []string `json:"extensions"`
	Compressible bool     `json:"compressible"`
	Charset      string   `json:"charset"`
}

func getDatabase(ctx context.Context, tag string) (map[string]entry, error) {
	req, err := http.NewRequestWithContext(ctx, http.MethodGet, fmt.Sprintf(databaseURL, tag), nil)
	if err != nil {
		return nil, err
	}
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	data, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	var v map[string]entry
	if err := json.Unmarshal(data, &v); err != nil {
		return nil, err
	}
	return v, nil
}
